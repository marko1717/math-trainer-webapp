<!DOCTYPE html>
<html lang="uk" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–î–æ—Å–ª—ñ–¥–Ω–∏–∫ –≥—Ä–∞—Ñ—ñ–∫—ñ–≤ | Math Quest</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <!-- Shared styles -->
    <link rel="stylesheet" href="../shared/styles/base.css">
    <link rel="stylesheet" href="../shared/styles/components.css">

    <style>
        * { box-sizing: border-box; }

        .explorer-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }

        .explorer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .back-link {
            color: var(--text-muted);
            text-decoration: none;
            font-size: 0.95rem;
        }

        .back-link:hover { color: var(--accent); }

        .explorer-title {
            font-size: 1.4rem;
            color: var(--text);
        }

        /* Function tabs */
        .function-tabs {
            display: flex;
            gap: 0.5rem;
            overflow-x: auto;
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }

        .function-tab {
            padding: 0.6rem 1rem;
            background: var(--card-bg);
            border: 2px solid var(--border);
            border-radius: 10px;
            font-size: 0.9rem;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s ease;
        }

        .function-tab.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .function-tab:hover:not(.active) {
            border-color: var(--accent);
        }

        /* Main layout */
        .explorer-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }

        @media (min-width: 900px) {
            .explorer-content {
                grid-template-columns: 1fr 350px;
            }
        }

        /* Graph panel */
        .graph-panel {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 1rem;
            border: 2px solid var(--border);
        }

        #mainCanvas {
            width: 100%;
            height: 400px;
            background: var(--bg);
            border-radius: 12px;
            cursor: crosshair;
            touch-action: none;
        }

        @media (min-width: 900px) {
            #mainCanvas { height: 500px; }
        }

        .graph-info {
            display: flex;
            justify-content: space-between;
            margin-top: 0.75rem;
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        /* Controls panel */
        .controls-panel {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 1.25rem;
            border: 2px solid var(--border);
        }

        .formula-display {
            background: var(--bg);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
            margin-bottom: 1rem;
            font-size: 1.5rem;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .controls-section {
            margin-bottom: 1.25rem;
        }

        .controls-section:last-child {
            margin-bottom: 0;
        }

        .section-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Sliders */
        .slider-group {
            margin-bottom: 1rem;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .slider-label {
            font-size: 0.9rem;
            color: var(--text);
        }

        .slider-value {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--accent);
            min-width: 50px;
            text-align: right;
        }

        .slider-container {
            position: relative;
        }

        input[type="range"] {
            width: 100%;
            height: 12px;
            border-radius: 6px;
            background: var(--border);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
            touch-action: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.4);
            transition: transform 0.2s ease;
            border: 3px solid white;
        }

        input[type="range"]::-webkit-slider-thumb:hover,
        input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.15);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.5);
        }

        /* Mobile-friendly slider touch area */
        .slider-container {
            padding: 8px 0;
        }

        /* Transformation description */
        .transform-description {
            background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
            border-radius: 12px;
            padding: 1rem;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        .transform-text {
            font-size: 0.95rem;
            color: var(--text);
            line-height: 1.6;
        }

        .transform-text .highlight {
            background: rgba(99, 102, 241, 0.2);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }

        .transform-text .up { color: #10b981; }
        .transform-text .down { color: #ef4444; }
        .transform-text .left { color: #f59e0b; }
        .transform-text .right { color: #8b5cf6; }

        /* Quick buttons */
        .quick-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .quick-btn {
            padding: 0.5rem 0.75rem;
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 8px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .quick-btn:hover {
            border-color: var(--accent);
        }

        .quick-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        /* Legend */
        .graph-legend {
            display: flex;
            gap: 1rem;
            margin-top: 0.75rem;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .legend-line {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        .legend-line.original { background: rgba(99, 102, 241, 0.4); }
        .legend-line.transformed { background: #6366f1; }

        /* Animations toggle */
        .animation-toggle {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: var(--bg);
            border-radius: 10px;
            margin-top: 1rem;
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 26px;
            background: var(--border);
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle-switch.active {
            background: var(--accent);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch.active::after {
            transform: translateX(22px);
        }

        .toggle-label {
            font-size: 0.9rem;
            color: var(--text);
        }

        /* Reset button */
        .reset-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 10px;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 1rem;
        }

        .reset-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Mode tabs */
        .mode-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            background: var(--bg);
            padding: 0.5rem;
            border-radius: 12px;
        }

        .mode-tab {
            flex: 1;
            padding: 0.75rem 1rem;
            background: transparent;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-muted);
        }

        .mode-tab.active {
            background: var(--accent);
            color: white;
        }

        .mode-tab:hover:not(.active) {
            background: var(--border);
        }

        /* Intersection controls */
        .intersection-controls {
            display: none;
        }

        .intersection-controls.active {
            display: block;
        }

        .function-select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border);
            border-radius: 10px;
            background: var(--bg);
            color: var(--text);
            font-size: 0.95rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
        }

        .function-select:focus {
            border-color: var(--accent);
            outline: none;
        }

        .function-label {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .function-color {
            width: 16px;
            height: 3px;
            border-radius: 2px;
        }

        .function-color.f1 { background: #6366f1; }
        .function-color.f2 { background: #10b981; }

        .param-input-group {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .param-input {
            flex: 1;
            padding: 0.6rem;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: var(--bg);
            color: var(--text);
            font-size: 0.9rem;
            text-align: center;
        }

        .param-input:focus {
            border-color: var(--accent);
            outline: none;
        }

        .param-input-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-align: center;
            margin-bottom: 0.25rem;
        }

        .intersection-points {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(52, 211, 153, 0.1));
            border-radius: 12px;
            padding: 1rem;
            border: 1px solid rgba(16, 185, 129, 0.2);
            margin-top: 1rem;
        }

        .intersection-title {
            font-weight: 600;
            color: #10b981;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .intersection-list {
            font-size: 0.95rem;
            color: var(--text);
        }

        .intersection-point {
            padding: 0.5rem;
            background: var(--card-bg);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .intersection-point:last-child {
            margin-bottom: 0;
        }

        .point-marker {
            width: 10px;
            height: 10px;
            background: #ef4444;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .no-intersection {
            color: var(--text-muted);
            font-style: italic;
        }

        /* Legend for intersection mode */
        .legend-line.func1 { background: #6366f1; }
        .legend-line.func2 { background: #10b981; }
        .legend-dot {
            width: 10px;
            height: 10px;
            background: #ef4444;
            border-radius: 50%;
        }

        /* AI hint section */
        .ai-hint-section {
            margin-top: 1rem;
            padding: 1rem;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(52, 211, 153, 0.1));
            border-radius: 12px;
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .ai-hint-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #10b981;
        }

        .ai-hint-text {
            font-size: 0.9rem;
            color: var(--text);
            line-height: 1.6;
        }
    </style>

    <script src="../shared/theme.js"></script>
</head>
<body>
    <div class="explorer-container">
        <div class="explorer-header">
            <a href="../index.html" class="back-link">‚Üê –ú–µ–Ω—é</a>
            <h1 class="explorer-title">üìä –î–æ—Å–ª—ñ–¥–Ω–∏–∫ –≥—Ä–∞—Ñ—ñ–∫—ñ–≤</h1>
            <div></div>
        </div>

        <!-- Function tabs -->
        <div class="function-tabs" id="functionTabs">
            <button class="function-tab active" data-func="linear">–õ—ñ–Ω—ñ–π–Ω–∞</button>
            <button class="function-tab" data-func="parabola">–ü–∞—Ä–∞–±–æ–ª–∞</button>
            <button class="function-tab" data-func="sqrt">‚àöx</button>
            <button class="function-tab" data-func="abs">|x|</button>
            <button class="function-tab" data-func="cubic">x¬≥</button>
            <button class="function-tab" data-func="hyperbola">1/x</button>
            <button class="function-tab" data-func="sin">sin x</button>
            <button class="function-tab" data-func="cos">cos x</button>
            <button class="function-tab" data-func="exp">aÀ£</button>
            <button class="function-tab" data-func="log">log x</button>
        </div>

        <div class="explorer-content">
            <!-- Graph panel -->
            <div class="graph-panel">
                <canvas id="mainCanvas"></canvas>
                <div class="graph-legend" id="graphLegend">
                    <div class="legend-item">
                        <div class="legend-line original"></div>
                        <span>–ë–∞–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line transformed"></div>
                        <span>–ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–∞</span>
                    </div>
                </div>
                <div class="graph-legend hidden" id="intersectionLegend">
                    <div class="legend-item">
                        <div class="legend-line func1"></div>
                        <span>f(x)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line func2"></div>
                        <span>g(x)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot"></div>
                        <span>–ü–µ—Ä–µ—Ç–∏–Ω</span>
                    </div>
                </div>
                <div class="graph-info">
                    <span id="cursorPos">x: 0, y: 0</span>
                    <span id="zoomLevel">–ú–∞—Å—à—Ç–∞–±: 1x</span>
                </div>
            </div>

            <!-- Controls panel -->
            <div class="controls-panel">
                <!-- Mode tabs -->
                <div class="mode-tabs">
                    <button class="mode-tab active" data-mode="transform">üìä –ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è</button>
                    <button class="mode-tab" data-mode="intersection">‚úñÔ∏è –ü–µ—Ä–µ—Ç–∏–Ω</button>
                </div>

                <!-- Transform mode controls -->
                <div id="transformMode">
                    <div class="formula-display" id="formulaDisplay">
                        <!-- KaTeX formula will be rendered here -->
                    </div>

                    <div class="controls-section" id="transformControls">
                        <div class="section-title">‚öôÔ∏è –ü–∞—Ä–∞–º–µ—Ç—Ä–∏</div>
                        <!-- Sliders will be generated dynamically -->
                    </div>

                    <div class="controls-section">
                        <div class="section-title">üéØ –®–≤–∏–¥–∫—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</div>
                        <div class="quick-buttons" id="quickButtons">
                            <button class="quick-btn" data-action="reset">–°–∫–∏–Ω—É—Ç–∏</button>
                            <button class="quick-btn" data-action="flip-x">–í—ñ–¥–æ–±—Ä–∞–∑–∏—Ç–∏ X</button>
                            <button class="quick-btn" data-action="flip-y">–í—ñ–¥–æ–±—Ä–∞–∑–∏—Ç–∏ Y</button>
                            <button class="quick-btn" data-action="stretch">–†–æ–∑—Ç—è–≥–Ω—É—Ç–∏</button>
                            <button class="quick-btn" data-action="compress">–°—Ç–∏—Å–Ω—É—Ç–∏</button>
                        </div>
                    </div>

                    <div class="transform-description" id="transformDescription">
                        <div class="transform-text">
                            –†—É—Ö–∞–π –ø–æ–≤–∑—É–Ω–∫–∏, —â–æ–± –ø–æ–±–∞—á–∏—Ç–∏, —è–∫ –∑–º—ñ–Ω—é—î—Ç—å—Å—è –≥—Ä–∞—Ñ—ñ–∫ —Ñ—É–Ω–∫—Ü—ñ—ó!
                        </div>
                    </div>

                    <div class="ai-hint-section">
                        <div class="ai-hint-header">
                            <span>üí°</span>
                            <span>–ü—ñ–¥–∫–∞–∑–∫–∞</span>
                        </div>
                        <div class="ai-hint-text" id="aiHintText">
                            –í–∏–±–µ—Ä—ñ—Ç—å —Ç–∏–ø —Ñ—É–Ω–∫—Ü—ñ—ó —Ç–∞ –µ–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—É–π—Ç–µ –∑ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏!
                        </div>
                    </div>

                    <div class="animation-toggle">
                        <div class="toggle-switch" id="animToggle"></div>
                        <span class="toggle-label">–ü–æ–∫–∞–∑—É–≤–∞—Ç–∏ –∞–Ω—ñ–º–∞—Ü—ñ—é –ø–µ—Ä–µ—Ö–æ–¥—É</span>
                    </div>

                    <button class="reset-btn" id="resetBtn">üîÑ –°–∫–∏–Ω—É—Ç–∏ –≤—Å—ñ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏</button>
                </div>

                <!-- Intersection mode controls -->
                <div id="intersectionMode" class="intersection-controls">
                    <div class="section-title">üìà –ü–µ—Ä—à–∞ —Ñ—É–Ω–∫—Ü—ñ—è</div>
                    <div class="function-label"><div class="function-color f1"></div> f(x)</div>
                    <select class="function-select" id="func1Select">
                        <option value="linear">y = kx + b (–õ—ñ–Ω—ñ–π–Ω–∞)</option>
                        <option value="parabola">y = ax¬≤ + bx + c (–ü–∞—Ä–∞–±–æ–ª–∞)</option>
                        <option value="sqrt">y = a‚àöx + b (–ö–æ—Ä—ñ–Ω—å)</option>
                        <option value="abs">y = a|x| + b (–ú–æ–¥—É–ª—å)</option>
                        <option value="hyperbola">y = a/x + b (–ì—ñ–ø–µ—Ä–±–æ–ª–∞)</option>
                        <option value="sin">y = a¬∑sin(kx) + b (–°–∏–Ω—É—Å)</option>
                        <option value="cos">y = a¬∑cos(kx) + b (–ö–æ—Å–∏–Ω—É—Å)</option>
                        <option value="exp">y = aÀ£ + b (–ü–æ–∫–∞–∑–Ω–∏–∫–æ–≤–∞)</option>
                        <option value="horizontal">y = c (–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞)</option>
                        <option value="vertical">x = c (–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞)</option>
                    </select>
                    <div id="func1Params" class="param-input-group"></div>

                    <div class="section-title" style="margin-top: 1rem;">üìâ –î—Ä—É–≥–∞ —Ñ—É–Ω–∫—Ü—ñ—è</div>
                    <div class="function-label"><div class="function-color f2"></div> g(x)</div>
                    <select class="function-select" id="func2Select">
                        <option value="horizontal" selected>y = c (–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞)</option>
                        <option value="vertical">x = c (–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞)</option>
                        <option value="linear">y = kx + b (–õ—ñ–Ω—ñ–π–Ω–∞)</option>
                        <option value="parabola">y = ax¬≤ + bx + c (–ü–∞—Ä–∞–±–æ–ª–∞)</option>
                        <option value="sqrt">y = a‚àöx + b (–ö–æ—Ä—ñ–Ω—å)</option>
                        <option value="abs">y = a|x| + b (–ú–æ–¥—É–ª—å)</option>
                        <option value="hyperbola">y = a/x + b (–ì—ñ–ø–µ—Ä–±–æ–ª–∞)</option>
                        <option value="sin">y = a¬∑sin(kx) + b (–°–∏–Ω—É—Å)</option>
                        <option value="cos">y = a¬∑cos(kx) + b (–ö–æ—Å–∏–Ω—É—Å)</option>
                        <option value="exp">y = aÀ£ + b (–ü–æ–∫–∞–∑–Ω–∏–∫–æ–≤–∞)</option>
                    </select>
                    <div id="func2Params" class="param-input-group"></div>

                    <div class="intersection-points" id="intersectionPoints">
                        <div class="intersection-title">
                            <span>üéØ</span>
                            <span>–¢–æ—á–∫–∏ –ø–µ—Ä–µ—Ç–∏–Ω—É</span>
                        </div>
                        <div class="intersection-list" id="intersectionList">
                            <div class="no-intersection">–í–∏–±–µ—Ä—ñ—Ç—å —Ñ—É–Ω–∫—Ü—ñ—ó —Ç–∞ –Ω–∞—Ç–∏—Å–Ω—ñ—Ç—å "–ó–Ω–∞–π—Ç–∏"</div>
                        </div>
                    </div>

                    <button class="reset-btn" id="findIntersectionBtn" style="background: var(--accent); color: white; border-color: var(--accent); margin-top: 1rem;">
                        üîç –ó–Ω–∞–π—Ç–∏ –ø–µ—Ä–µ—Ç–∏–Ω
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============ FUNCTION DEFINITIONS ============
        const FUNCTIONS = {
            linear: {
                name: '–õ—ñ–Ω—ñ–π–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è',
                baseFormula: 'y = x',
                formula: (params) => `y = ${params.k !== 1 ? params.k : ''}x ${params.b >= 0 ? '+' : '-'} ${Math.abs(params.b)}`,
                latexFormula: (params) => {
                    let k = params.k;
                    let b = params.b;
                    let kStr = k === 1 ? '' : (k === -1 ? '-' : k);
                    let bStr = b === 0 ? '' : (b > 0 ? `+ ${b}` : `- ${Math.abs(b)}`);
                    return `y = ${kStr}x ${bStr}`.trim();
                },
                params: [
                    { id: 'k', name: '–ö—É—Ç–æ–≤–∏–π –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç (k)', min: -5, max: 5, step: 0.5, default: 1 },
                    { id: 'b', name: '–í—ñ–ª—å–Ω–∏–π —á–ª–µ–Ω (b)', min: -5, max: 5, step: 0.5, default: 0 }
                ],
                compute: (x, params) => params.k * x + params.b,
                baseCompute: (x) => x,
                describe: (params) => {
                    let desc = [];
                    if (params.k > 1) desc.push(`<span class="highlight">k = ${params.k}</span> ‚Äî —Ñ—É–Ω–∫—Ü—ñ—è <span class="up">–∑—Ä–æ—Å—Ç–∞—î —à–≤–∏–¥—à–µ</span>`);
                    else if (params.k > 0 && params.k < 1) desc.push(`<span class="highlight">k = ${params.k}</span> ‚Äî —Ñ—É–Ω–∫—Ü—ñ—è <span class="down">–∑—Ä–æ—Å—Ç–∞—î –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ</span>`);
                    else if (params.k < 0) desc.push(`<span class="highlight">k = ${params.k}</span> ‚Äî —Ñ—É–Ω–∫—Ü—ñ—è <span class="down">—Å–ø–∞–¥–∞—î</span>`);
                    else if (params.k === 0) desc.push(`<span class="highlight">k = 0</span> ‚Äî –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞ –ø—Ä—è–º–∞`);

                    if (params.b > 0) desc.push(`<span class="highlight">b = ${params.b}</span> ‚Äî –∑—Å—É–≤ <span class="up">–≤–≥–æ—Ä—É</span> –Ω–∞ ${params.b}`);
                    else if (params.b < 0) desc.push(`<span class="highlight">b = ${params.b}</span> ‚Äî –∑—Å—É–≤ <span class="down">–≤–Ω–∏–∑</span> –Ω–∞ ${Math.abs(params.b)}`);

                    return desc.join('<br>') || '–ë–∞–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è y = x';
                },
                hint: 'k –≤–∏–∑–Ω–∞—á–∞—î –Ω–∞—Ö–∏–ª –ø—Ä—è–º–æ—ó: k > 0 ‚Äî –∑—Ä–æ—Å—Ç–∞—î, k < 0 ‚Äî —Å–ø–∞–¥–∞—î. b ‚Äî —Ç–æ—á–∫–∞ –ø–µ—Ä–µ—Ç–∏–Ω—É –∑ –≤—ñ—Å—Å—é Y.'
            },
            parabola: {
                name: '–ü–∞—Ä–∞–±–æ–ª–∞',
                baseFormula: 'y = x¬≤',
                latexFormula: (params) => {
                    let a = params.a;
                    let p = params.p;
                    let q = params.q;
                    let aStr = a === 1 ? '' : (a === -1 ? '-' : a);
                    let pStr = p === 0 ? 'x' : (p > 0 ? `(x - ${p})` : `(x + ${Math.abs(p)})`);
                    let qStr = q === 0 ? '' : (q > 0 ? ` + ${q}` : ` - ${Math.abs(q)}`);
                    return `y = ${aStr}${pStr}^2${qStr}`;
                },
                params: [
                    { id: 'a', name: '–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç a (—Ä–æ–∑—Ç—è–≥/—Å—Ç–∏—Å–∫)', min: -3, max: 3, step: 0.5, default: 1 },
                    { id: 'p', name: '–ó—Å—É–≤ –ø–æ X (p)', min: -5, max: 5, step: 0.5, default: 0 },
                    { id: 'q', name: '–ó—Å—É–≤ –ø–æ Y (q)', min: -5, max: 5, step: 0.5, default: 0 }
                ],
                compute: (x, params) => params.a * Math.pow(x - params.p, 2) + params.q,
                baseCompute: (x) => x * x,
                describe: (params) => {
                    let desc = [];
                    if (params.a > 1) desc.push(`<span class="highlight">a = ${params.a}</span> ‚Äî –ø–∞—Ä–∞–±–æ–ª–∞ <span class="up">–≤—É–∂—á–∞</span>`);
                    else if (params.a > 0 && params.a < 1) desc.push(`<span class="highlight">a = ${params.a}</span> ‚Äî –ø–∞—Ä–∞–±–æ–ª–∞ <span class="down">—à–∏—Ä—à–∞</span>`);
                    else if (params.a < 0) desc.push(`<span class="highlight">a = ${params.a}</span> ‚Äî –ø–∞—Ä–∞–±–æ–ª–∞ <span class="down">–ø–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç–∞</span>`);

                    if (params.p > 0) desc.push(`<span class="highlight">p = ${params.p}</span> ‚Äî –∑—Å—É–≤ <span class="right">–≤–ø—Ä–∞–≤–æ</span> –Ω–∞ ${params.p}`);
                    else if (params.p < 0) desc.push(`<span class="highlight">p = ${params.p}</span> ‚Äî –∑—Å—É–≤ <span class="left">–≤–ª—ñ–≤–æ</span> –Ω–∞ ${Math.abs(params.p)}`);

                    if (params.q > 0) desc.push(`<span class="highlight">q = ${params.q}</span> ‚Äî –∑—Å—É–≤ <span class="up">–≤–≥–æ—Ä—É</span> –Ω–∞ ${params.q}`);
                    else if (params.q < 0) desc.push(`<span class="highlight">q = ${params.q}</span> ‚Äî –∑—Å—É–≤ <span class="down">–≤–Ω–∏–∑</span> –Ω–∞ ${Math.abs(params.q)}`);

                    desc.push(`–í–µ—Ä—à–∏–Ω–∞: (${params.p}, ${params.q})`);

                    return desc.join('<br>') || '–ë–∞–∑–æ–≤–∞ –ø–∞—Ä–∞–±–æ–ª–∞ y = x¬≤';
                },
                hint: '–§–æ—Ä–º—É–ª–∞ y = a(x-p)¬≤ + q. –í–µ—Ä—à–∏–Ω–∞ –ø–∞—Ä–∞–±–æ–ª–∏ –≤ —Ç–æ—á—Ü—ñ (p, q). –Ø–∫—â–æ a < 0 ‚Äî –≤—ñ—Ç–∫–∏ –≤–Ω–∏–∑.'
            },
            sqrt: {
                name: '–ö–æ—Ä—ñ–Ω—å',
                baseFormula: 'y = ‚àöx',
                latexFormula: (params) => {
                    let a = params.a;
                    let p = params.p;
                    let q = params.q;
                    let aStr = a === 1 ? '' : (a === -1 ? '-' : a);
                    let inner = p === 0 ? 'x' : (p > 0 ? `x - ${p}` : `x + ${Math.abs(p)}`);
                    let qStr = q === 0 ? '' : (q > 0 ? ` + ${q}` : ` - ${Math.abs(q)}`);
                    return `y = ${aStr}\\sqrt{${inner}}${qStr}`;
                },
                params: [
                    { id: 'a', name: '–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç a', min: -3, max: 3, step: 0.5, default: 1 },
                    { id: 'p', name: '–ó—Å—É–≤ –ø–æ X (p)', min: -5, max: 5, step: 0.5, default: 0 },
                    { id: 'q', name: '–ó—Å—É–≤ –ø–æ Y (q)', min: -5, max: 5, step: 0.5, default: 0 }
                ],
                compute: (x, params) => {
                    const inner = x - params.p;
                    if (inner < 0) return NaN;
                    return params.a * Math.sqrt(inner) + params.q;
                },
                baseCompute: (x) => x >= 0 ? Math.sqrt(x) : NaN,
                describe: (params) => {
                    let desc = [];
                    if (params.a < 0) desc.push(`<span class="highlight">a < 0</span> ‚Äî –≥—Ä–∞—Ñ—ñ–∫ <span class="down">–≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤—ñ–¥–Ω–æ—Å–Ω–æ OX</span>`);
                    if (params.p !== 0) desc.push(`–û–±–ª–∞—Å—Ç—å –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è: x ‚â• ${params.p}`);
                    if (params.q !== 0) desc.push(`–ü–æ—á–∞—Ç–∫–æ–≤–∞ —Ç–æ—á–∫–∞: (${params.p}, ${params.q})`);
                    return desc.join('<br>') || '–ë–∞–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è y = ‚àöx';
                },
                hint: '–§—É–Ω–∫—Ü—ñ—è –≤–∏–∑–Ω–∞—á–µ–Ω–∞ —Ç—ñ–ª—å–∫–∏ –¥–ª—è x ‚â• p. –ó—Å—É–≤ p –ø–µ—Ä–µ–º—ñ—â—É—î –ø–æ—á–∞—Ç–æ–∫ –≥—Ä–∞—Ñ—ñ–∫–∞ –ø–æ –æ—Å—ñ X.'
            },
            abs: {
                name: '–ú–æ–¥—É–ª—å',
                baseFormula: 'y = |x|',
                latexFormula: (params) => {
                    let a = params.a;
                    let p = params.p;
                    let q = params.q;
                    let aStr = a === 1 ? '' : (a === -1 ? '-' : a);
                    let inner = p === 0 ? 'x' : (p > 0 ? `x - ${p}` : `x + ${Math.abs(p)}`);
                    let qStr = q === 0 ? '' : (q > 0 ? ` + ${q}` : ` - ${Math.abs(q)}`);
                    return `y = ${aStr}|${inner}|${qStr}`;
                },
                params: [
                    { id: 'a', name: '–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç a', min: -3, max: 3, step: 0.5, default: 1 },
                    { id: 'p', name: '–ó—Å—É–≤ –ø–æ X (p)', min: -5, max: 5, step: 0.5, default: 0 },
                    { id: 'q', name: '–ó—Å—É–≤ –ø–æ Y (q)', min: -5, max: 5, step: 0.5, default: 0 }
                ],
                compute: (x, params) => params.a * Math.abs(x - params.p) + params.q,
                baseCompute: (x) => Math.abs(x),
                describe: (params) => {
                    let desc = [];
                    if (params.a < 0) desc.push(`<span class="highlight">a < 0</span> ‚Äî "–∫—É—Ç" <span class="down">–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π –≤–Ω–∏–∑</span>`);
                    if (params.a !== 1 && params.a !== -1) desc.push(`|a| = ${Math.abs(params.a)} ‚Äî –∑–º—ñ–Ω–∞ –∫—É—Ç–∞ –Ω–∞—Ö–∏–ª—É`);
                    desc.push(`–í–µ—Ä—à–∏–Ω–∞: (${params.p}, ${params.q})`);
                    return desc.join('<br>') || '–ë–∞–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è y = |x|';
                },
                hint: '–ì—Ä–∞—Ñ—ñ–∫ –º–æ–¥—É–ª—è ‚Äî —Ü–µ "–∫—É—Ç". –í–µ—Ä—à–∏–Ω–∞ –∫—É—Ç–∞ –∑–Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤ —Ç–æ—á—Ü—ñ (p, q).'
            },
            cubic: {
                name: '–ö—É–±—ñ—á–Ω–∞',
                baseFormula: 'y = x¬≥',
                latexFormula: (params) => {
                    let a = params.a;
                    let p = params.p;
                    let q = params.q;
                    let aStr = a === 1 ? '' : (a === -1 ? '-' : a);
                    let inner = p === 0 ? 'x' : (p > 0 ? `(x - ${p})` : `(x + ${Math.abs(p)})`);
                    let qStr = q === 0 ? '' : (q > 0 ? ` + ${q}` : ` - ${Math.abs(q)}`);
                    return `y = ${aStr}${inner}^3${qStr}`;
                },
                params: [
                    { id: 'a', name: '–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç a', min: -2, max: 2, step: 0.25, default: 1 },
                    { id: 'p', name: '–ó—Å—É–≤ –ø–æ X (p)', min: -5, max: 5, step: 0.5, default: 0 },
                    { id: 'q', name: '–ó—Å—É–≤ –ø–æ Y (q)', min: -5, max: 5, step: 0.5, default: 0 }
                ],
                compute: (x, params) => params.a * Math.pow(x - params.p, 3) + params.q,
                baseCompute: (x) => x * x * x,
                describe: (params) => {
                    let desc = [];
                    if (params.a < 0) desc.push(`<span class="highlight">a < 0</span> ‚Äî –≥—Ä–∞—Ñ—ñ–∫ <span class="down">–≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–∏–π</span>`);
                    desc.push(`–¢–æ—á–∫–∞ –ø–µ—Ä–µ–≥–∏–Ω—É: (${params.p}, ${params.q})`);
                    return desc.join('<br>') || '–ë–∞–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü—ñ—è y = x¬≥';
                },
                hint: '–ö—É–±—ñ—á–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—è –ø—Ä–æ—Ö–æ–¥–∏—Ç—å —á–µ—Ä–µ–∑ –ø–æ—á–∞—Ç–æ–∫ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç —ñ –º–∞—î —Ç–æ—á–∫—É –ø–µ—Ä–µ–≥–∏–Ω—É.'
            },
            hyperbola: {
                name: '–ì—ñ–ø–µ—Ä–±–æ–ª–∞',
                baseFormula: 'y = 1/x',
                latexFormula: (params) => {
                    let a = params.a;
                    let p = params.p;
                    let q = params.q;
                    let inner = p === 0 ? 'x' : (p > 0 ? `x - ${p}` : `x + ${Math.abs(p)}`);
                    let qStr = q === 0 ? '' : (q > 0 ? ` + ${q}` : ` - ${Math.abs(q)}`);
                    return `y = \\frac{${a}}{${inner}}${qStr}`;
                },
                params: [
                    { id: 'a', name: '–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç a', min: -5, max: 5, step: 0.5, default: 1 },
                    { id: 'p', name: '–ó—Å—É–≤ –ø–æ X (p)', min: -5, max: 5, step: 0.5, default: 0 },
                    { id: 'q', name: '–ó—Å—É–≤ –ø–æ Y (q)', min: -5, max: 5, step: 0.5, default: 0 }
                ],
                compute: (x, params) => {
                    const denom = x - params.p;
                    if (Math.abs(denom) < 0.01) return NaN;
                    return params.a / denom + params.q;
                },
                baseCompute: (x) => Math.abs(x) < 0.01 ? NaN : 1 / x,
                describe: (params) => {
                    let desc = [];
                    desc.push(`–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞ –∞—Å–∏–º–ø—Ç–æ—Ç–∞: x = ${params.p}`);
                    desc.push(`–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞ –∞—Å–∏–º–ø—Ç–æ—Ç–∞: y = ${params.q}`);
                    if (params.a < 0) desc.push(`<span class="highlight">a < 0</span> ‚Äî –≥—ñ–ø–µ—Ä–±–æ–ª–∞ –≤ II —ñ IV —á–≤–µ—Ä—Ç—è—Ö`);
                    return desc.join('<br>');
                },
                hint: '–ì—ñ–ø–µ—Ä–±–æ–ª–∞ –º–∞—î –¥–≤—ñ –∞—Å–∏–º–ø—Ç–æ—Ç–∏. –¶–µ–Ω—Ç—Ä –≥—ñ–ø–µ—Ä–±–æ–ª–∏ –≤ —Ç–æ—á—Ü—ñ (p, q).'
            },
            sin: {
                name: '–°–∏–Ω—É—Å',
                baseFormula: 'y = sin(x)',
                latexFormula: (params) => {
                    let a = params.a;
                    let k = params.k;
                    let p = params.p;
                    let q = params.q;
                    let aStr = a === 1 ? '' : (a === -1 ? '-' : a);
                    let kStr = k === 1 ? '' : k;
                    let inner = p === 0 ? `${kStr}x` : (p > 0 ? `${kStr}x - ${p}` : `${kStr}x + ${Math.abs(p)}`);
                    let qStr = q === 0 ? '' : (q > 0 ? ` + ${q}` : ` - ${Math.abs(q)}`);
                    return `y = ${aStr}\\sin(${inner})${qStr}`;
                },
                params: [
                    { id: 'a', name: '–ê–º–ø–ª—ñ—Ç—É–¥–∞ (a)', min: -3, max: 3, step: 0.5, default: 1 },
                    { id: 'k', name: '–ß–∞—Å—Ç–æ—Ç–∞ (k)', min: 0.5, max: 4, step: 0.5, default: 1 },
                    { id: 'p', name: '–§–∞–∑–∞ (p)', min: -3.14, max: 3.14, step: 0.314, default: 0 },
                    { id: 'q', name: '–ó—Å—É–≤ –ø–æ Y (q)', min: -3, max: 3, step: 0.5, default: 0 }
                ],
                compute: (x, params) => params.a * Math.sin(params.k * x - params.p) + params.q,
                baseCompute: (x) => Math.sin(x),
                describe: (params) => {
                    let desc = [];
                    desc.push(`–ê–º–ø–ª—ñ—Ç—É–¥–∞: ${Math.abs(params.a)}`);
                    desc.push(`–ü–µ—Ä—ñ–æ–¥: T = ${(2 * Math.PI / params.k).toFixed(2)}`);
                    if (params.p !== 0) desc.push(`–§–∞–∑–æ–≤–∏–π –∑—Å—É–≤: ${params.p.toFixed(2)} —Ä–∞–¥`);
                    if (params.q !== 0) desc.push(`–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∏–π –∑—Å—É–≤: ${params.q}`);
                    return desc.join('<br>');
                },
                hint: '–ê–º–ø–ª—ñ—Ç—É–¥–∞ ‚Äî –≤–∏—Å–æ—Ç–∞ —Ö–≤–∏–ª—ñ. –ü–µ—Ä—ñ–æ–¥ T = 2œÄ/k. –§–∞–∑–∞ –∑—Å—É–≤–∞—î –≥—Ä–∞—Ñ—ñ–∫ –ø–æ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—ñ.'
            },
            cos: {
                name: '–ö–æ—Å–∏–Ω—É—Å',
                baseFormula: 'y = cos(x)',
                latexFormula: (params) => {
                    let a = params.a;
                    let k = params.k;
                    let p = params.p;
                    let q = params.q;
                    let aStr = a === 1 ? '' : (a === -1 ? '-' : a);
                    let kStr = k === 1 ? '' : k;
                    let inner = p === 0 ? `${kStr}x` : (p > 0 ? `${kStr}x - ${p}` : `${kStr}x + ${Math.abs(p)}`);
                    let qStr = q === 0 ? '' : (q > 0 ? ` + ${q}` : ` - ${Math.abs(q)}`);
                    return `y = ${aStr}\\cos(${inner})${qStr}`;
                },
                params: [
                    { id: 'a', name: '–ê–º–ø–ª—ñ—Ç—É–¥–∞ (a)', min: -3, max: 3, step: 0.5, default: 1 },
                    { id: 'k', name: '–ß–∞—Å—Ç–æ—Ç–∞ (k)', min: 0.5, max: 4, step: 0.5, default: 1 },
                    { id: 'p', name: '–§–∞–∑–∞ (p)', min: -3.14, max: 3.14, step: 0.314, default: 0 },
                    { id: 'q', name: '–ó—Å—É–≤ –ø–æ Y (q)', min: -3, max: 3, step: 0.5, default: 0 }
                ],
                compute: (x, params) => params.a * Math.cos(params.k * x - params.p) + params.q,
                baseCompute: (x) => Math.cos(x),
                describe: (params) => {
                    let desc = [];
                    desc.push(`–ê–º–ø–ª—ñ—Ç—É–¥–∞: ${Math.abs(params.a)}`);
                    desc.push(`–ü–µ—Ä—ñ–æ–¥: T = ${(2 * Math.PI / params.k).toFixed(2)}`);
                    if (params.p !== 0) desc.push(`–§–∞–∑–æ–≤–∏–π –∑—Å—É–≤: ${params.p.toFixed(2)} —Ä–∞–¥`);
                    return desc.join('<br>');
                },
                hint: '–ö–æ—Å–∏–Ω—É—Å ‚Äî —Ü–µ —Å–∏–Ω—É—Å, –∑—Å—É–Ω—É—Ç–∏–π –Ω–∞ œÄ/2 –≤–ª—ñ–≤–æ. cos(x) = sin(x + œÄ/2).'
            },
            exp: {
                name: '–ü–æ–∫–∞–∑–Ω–∏–∫–æ–≤–∞',
                baseFormula: 'y = aÀ£',
                latexFormula: (params) => {
                    let base = params.base;
                    let k = params.k;
                    let p = params.p;
                    let q = params.q;
                    let inner = p === 0 ? `${k !== 1 ? k : ''}x` : (p > 0 ? `${k !== 1 ? k : ''}x - ${p}` : `${k !== 1 ? k : ''}x + ${Math.abs(p)}`);
                    let qStr = q === 0 ? '' : (q > 0 ? ` + ${q}` : ` - ${Math.abs(q)}`);
                    return `y = ${base}^{${inner}}${qStr}`;
                },
                params: [
                    { id: 'base', name: '–û—Å–Ω–æ–≤–∞ (a)', min: 0.5, max: 4, step: 0.5, default: 2 },
                    { id: 'k', name: '–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç k', min: -2, max: 2, step: 0.5, default: 1 },
                    { id: 'p', name: '–ó—Å—É–≤ –ø–æ X (p)', min: -5, max: 5, step: 0.5, default: 0 },
                    { id: 'q', name: '–ó—Å—É–≤ –ø–æ Y (q)', min: -5, max: 5, step: 0.5, default: 0 }
                ],
                compute: (x, params) => Math.pow(params.base, params.k * x - params.p) + params.q,
                baseCompute: (x) => Math.pow(2, x),
                describe: (params) => {
                    let desc = [];
                    if (params.base > 1) desc.push(`–û—Å–Ω–æ–≤–∞ ${params.base} > 1 ‚Äî —Ñ—É–Ω–∫—Ü—ñ—è <span class="up">–∑—Ä–æ—Å—Ç–∞—î</span>`);
                    else if (params.base < 1) desc.push(`–û—Å–Ω–æ–≤–∞ ${params.base} < 1 ‚Äî —Ñ—É–Ω–∫—Ü—ñ—è <span class="down">—Å–ø–∞–¥–∞—î</span>`);
                    desc.push(`–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞ –∞—Å–∏–º–ø—Ç–æ—Ç–∞: y = ${params.q}`);
                    return desc.join('<br>');
                },
                hint: '–Ø–∫—â–æ –æ—Å–Ω–æ–≤–∞ a > 1 ‚Äî —Ñ—É–Ω–∫—Ü—ñ—è –∑—Ä–æ—Å—Ç–∞—î. –Ø–∫—â–æ 0 < a < 1 ‚Äî —Å–ø–∞–¥–∞—î. –ê—Å–∏–º–ø—Ç–æ—Ç–∞ y = q.'
            },
            log: {
                name: '–õ–æ–≥–∞—Ä–∏—Ñ–º—ñ—á–Ω–∞',
                baseFormula: 'y = log(x)',
                latexFormula: (params) => {
                    let base = params.base;
                    let k = params.k;
                    let p = params.p;
                    let q = params.q;
                    let kStr = k === 1 ? '' : (k === -1 ? '-' : k);
                    let inner = p === 0 ? 'x' : (p > 0 ? `x - ${p}` : `x + ${Math.abs(p)}`);
                    let qStr = q === 0 ? '' : (q > 0 ? ` + ${q}` : ` - ${Math.abs(q)}`);
                    let logStr = base === Math.E ? '\\ln' : `\\log_{${base}}`;
                    return `y = ${kStr}${logStr}(${inner})${qStr}`;
                },
                params: [
                    { id: 'base', name: '–û—Å–Ω–æ–≤–∞ –ª–æ–≥–∞—Ä–∏—Ñ–º–∞', min: 2, max: 10, step: 1, default: 2 },
                    { id: 'k', name: '–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç k', min: -2, max: 2, step: 0.5, default: 1 },
                    { id: 'p', name: '–ó—Å—É–≤ –ø–æ X (p)', min: -5, max: 5, step: 0.5, default: 0 },
                    { id: 'q', name: '–ó—Å—É–≤ –ø–æ Y (q)', min: -5, max: 5, step: 0.5, default: 0 }
                ],
                compute: (x, params) => {
                    const inner = x - params.p;
                    if (inner <= 0) return NaN;
                    return params.k * Math.log(inner) / Math.log(params.base) + params.q;
                },
                baseCompute: (x) => x > 0 ? Math.log2(x) : NaN,
                describe: (params) => {
                    let desc = [];
                    desc.push(`–û–±–ª–∞—Å—Ç—å –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è: x > ${params.p}`);
                    desc.push(`–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞ –∞—Å–∏–º–ø—Ç–æ—Ç–∞: x = ${params.p}`);
                    if (params.k < 0) desc.push(`<span class="highlight">k < 0</span> ‚Äî –≥—Ä–∞—Ñ—ñ–∫ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–∏–π`);
                    return desc.join('<br>');
                },
                hint: '–õ–æ–≥–∞—Ä–∏—Ñ–º –≤–∏–∑–Ω–∞—á–µ–Ω–∏–π —Ç—ñ–ª—å–∫–∏ –¥–ª—è –¥–æ–¥–∞—Ç–Ω–∏—Ö –∞—Ä–≥—É–º–µ–Ω—Ç—ñ–≤. –ê—Å–∏–º–ø—Ç–æ—Ç–∞ x = p.'
            }
        };

        // ============ GRAPH CONTROLLER ============
        class GraphExplorer {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');

                this.currentFunc = 'linear';
                this.params = {};
                this.animateTransitions = true;
                this.targetParams = {};
                this.animationFrame = null;

                this.scale = 40;
                this.offsetX = 0;
                this.offsetY = 0;

                this.initParams();
                this.resize();
                this.setupEventListeners();
                this.renderControls();
                this.draw();

                window.addEventListener('resize', () => this.resize());
            }

            initParams() {
                const func = FUNCTIONS[this.currentFunc];
                this.params = {};
                func.params.forEach(p => {
                    this.params[p.id] = p.default;
                });
            }

            resize() {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.width = rect.width;
                this.height = rect.height;
                this.centerX = this.width / 2 + this.offsetX;
                this.centerY = this.height / 2 + this.offsetY;
                this.draw();
            }

            setupEventListeners() {
                // Function tabs
                document.querySelectorAll('.function-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.function-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        this.currentFunc = tab.dataset.func;
                        this.initParams();
                        this.renderControls();
                        this.updateFormula();
                        this.updateDescription();
                        this.draw();
                    });
                });

                // Quick buttons
                document.querySelectorAll('.quick-btn').forEach(btn => {
                    btn.addEventListener('click', () => this.handleQuickAction(btn.dataset.action));
                });

                // Reset button
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.initParams();
                    this.renderControls();
                    this.updateFormula();
                    this.updateDescription();
                    this.draw();
                });

                // Animation toggle
                document.getElementById('animToggle').addEventListener('click', (e) => {
                    this.animateTransitions = !this.animateTransitions;
                    e.target.classList.toggle('active', this.animateTransitions);
                });

                // Mouse position
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = (e.clientX - rect.left - this.centerX) / this.scale;
                    const y = -(e.clientY - rect.top - this.centerY) / this.scale;
                    document.getElementById('cursorPos').textContent =
                        `x: ${x.toFixed(2)}, y: ${y.toFixed(2)}`;
                });

                // Zoom with wheel
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.scale *= delta;
                    this.scale = Math.max(20, Math.min(100, this.scale));
                    document.getElementById('zoomLevel').textContent =
                        `–ú–∞—Å—à—Ç–∞–±: ${(this.scale / 40).toFixed(1)}x`;
                    this.draw();
                });

                // Touch support for mobile
                let lastTouchDistance = 0;
                let touchStartX = 0;
                let touchStartY = 0;
                let isPanning = false;

                this.canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        // Pinch to zoom
                        const dx = e.touches[0].clientX - e.touches[1].clientX;
                        const dy = e.touches[0].clientY - e.touches[1].clientY;
                        lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                    } else if (e.touches.length === 1) {
                        // Pan
                        isPanning = true;
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                    }
                });

                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();

                    if (e.touches.length === 2) {
                        // Pinch zoom
                        const dx = e.touches[0].clientX - e.touches[1].clientX;
                        const dy = e.touches[0].clientY - e.touches[1].clientY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (lastTouchDistance > 0) {
                            const delta = distance / lastTouchDistance;
                            this.scale *= delta;
                            this.scale = Math.max(20, Math.min(100, this.scale));
                            document.getElementById('zoomLevel').textContent =
                                `–ú–∞—Å—à—Ç–∞–±: ${(this.scale / 40).toFixed(1)}x`;
                            this.draw();
                        }
                        lastTouchDistance = distance;
                    } else if (e.touches.length === 1 && isPanning) {
                        // Pan
                        const dx = e.touches[0].clientX - touchStartX;
                        const dy = e.touches[0].clientY - touchStartY;
                        this.offsetX += dx;
                        this.offsetY += dy;
                        this.centerX = this.width / 2 + this.offsetX;
                        this.centerY = this.height / 2 + this.offsetY;
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                        this.draw();

                        // Update cursor position
                        const rect = this.canvas.getBoundingClientRect();
                        const x = (e.touches[0].clientX - rect.left - this.centerX) / this.scale;
                        const y = -(e.touches[0].clientY - rect.top - this.centerY) / this.scale;
                        document.getElementById('cursorPos').textContent =
                            `x: ${x.toFixed(2)}, y: ${y.toFixed(2)}`;
                    }
                }, { passive: false });

                this.canvas.addEventListener('touchend', () => {
                    lastTouchDistance = 0;
                    isPanning = false;
                });
            }

            renderControls() {
                const func = FUNCTIONS[this.currentFunc];
                const container = document.getElementById('transformControls');

                let html = '<div class="section-title">‚öôÔ∏è –ü–∞—Ä–∞–º–µ—Ç—Ä–∏</div>';

                func.params.forEach(param => {
                    html += `
                        <div class="slider-group">
                            <div class="slider-header">
                                <span class="slider-label">${param.name}</span>
                                <span class="slider-value" id="${param.id}Value">${this.params[param.id]}</span>
                            </div>
                            <div class="slider-container">
                                <input type="range"
                                    id="${param.id}Slider"
                                    min="${param.min}"
                                    max="${param.max}"
                                    step="${param.step}"
                                    value="${this.params[param.id]}">
                            </div>
                        </div>
                    `;
                });

                container.innerHTML = html;

                // Bind slider events
                func.params.forEach(param => {
                    const slider = document.getElementById(`${param.id}Slider`);
                    slider.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        if (this.animateTransitions) {
                            this.animateParam(param.id, value);
                        } else {
                            this.params[param.id] = value;
                            document.getElementById(`${param.id}Value`).textContent = value;
                            this.updateFormula();
                            this.updateDescription();
                            this.draw();
                        }
                    });
                });

                this.updateFormula();
                this.updateDescription();

                // Update AI hint
                document.getElementById('aiHintText').textContent = func.hint;
            }

            animateParam(paramId, targetValue) {
                const startValue = this.params[paramId];
                const startTime = performance.now();
                const duration = 200;

                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 3); // ease-out cubic

                    this.params[paramId] = startValue + (targetValue - startValue) * eased;
                    document.getElementById(`${paramId}Value`).textContent =
                        this.params[paramId].toFixed(2);

                    this.updateFormula();
                    this.updateDescription();
                    this.draw();

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.params[paramId] = targetValue;
                        document.getElementById(`${paramId}Value`).textContent = targetValue;
                    }
                };

                requestAnimationFrame(animate);
            }

            handleQuickAction(action) {
                const func = FUNCTIONS[this.currentFunc];

                switch (action) {
                    case 'reset':
                        this.initParams();
                        break;
                    case 'flip-x':
                        if ('p' in this.params) this.params.p *= -1;
                        break;
                    case 'flip-y':
                        if ('a' in this.params) this.params.a *= -1;
                        if ('k' in this.params && this.currentFunc !== 'sin' && this.currentFunc !== 'cos')
                            this.params.k *= -1;
                        break;
                    case 'stretch':
                        if ('a' in this.params) this.params.a *= 1.5;
                        break;
                    case 'compress':
                        if ('a' in this.params) this.params.a *= 0.67;
                        break;
                }

                this.renderControls();
                this.updateFormula();
                this.updateDescription();
                this.draw();
            }

            updateFormula() {
                const func = FUNCTIONS[this.currentFunc];
                const latex = func.latexFormula(this.params);

                try {
                    katex.render(latex, document.getElementById('formulaDisplay'), {
                        throwOnError: false,
                        displayMode: true
                    });
                } catch (e) {
                    document.getElementById('formulaDisplay').textContent = latex;
                }
            }

            updateDescription() {
                const func = FUNCTIONS[this.currentFunc];
                document.getElementById('transformDescription').querySelector('.transform-text').innerHTML =
                    func.describe(this.params);
            }

            toCanvas(x, y) {
                return {
                    x: this.centerX + x * this.scale,
                    y: this.centerY - y * this.scale
                };
            }

            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.width, this.height);

                this.drawGrid();
                this.drawAxes();
                this.drawBaseFunction();
                this.drawTransformedFunction();
            }

            drawGrid() {
                const ctx = this.ctx;
                ctx.strokeStyle = 'rgba(128, 128, 128, 0.15)';
                ctx.lineWidth = 1;

                // Calculate grid bounds
                const step = this.scale;

                // Vertical lines
                for (let x = this.centerX % step; x < this.width; x += step) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, this.height);
                    ctx.stroke();
                }

                // Horizontal lines
                for (let y = this.centerY % step; y < this.height; y += step) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.width, y);
                    ctx.stroke();
                }
            }

            drawAxes() {
                const ctx = this.ctx;
                ctx.strokeStyle = 'rgba(128, 128, 128, 0.5)';
                ctx.lineWidth = 2;

                // X axis
                ctx.beginPath();
                ctx.moveTo(0, this.centerY);
                ctx.lineTo(this.width, this.centerY);
                ctx.stroke();

                // Y axis
                ctx.beginPath();
                ctx.moveTo(this.centerX, 0);
                ctx.lineTo(this.centerX, this.height);
                ctx.stroke();

                // Labels
                ctx.fillStyle = 'rgba(128, 128, 128, 0.7)';
                ctx.font = '12px Inter';
                ctx.fillText('x', this.width - 15, this.centerY - 8);
                ctx.fillText('y', this.centerX + 8, 15);

                // Numbers
                const step = this.scale;
                for (let i = -10; i <= 10; i++) {
                    if (i === 0) continue;

                    const px = this.centerX + i * step;
                    const py = this.centerY - i * step;

                    if (px > 0 && px < this.width) {
                        ctx.fillText(i.toString(), px - 4, this.centerY + 15);
                    }
                    if (py > 0 && py < this.height) {
                        ctx.fillText(i.toString(), this.centerX + 8, py + 4);
                    }
                }
            }

            drawBaseFunction() {
                const ctx = this.ctx;
                const func = FUNCTIONS[this.currentFunc];

                ctx.strokeStyle = 'rgba(99, 102, 241, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);

                this.plotFunction(func.baseCompute);

                ctx.setLineDash([]);
            }

            drawTransformedFunction() {
                const ctx = this.ctx;
                const func = FUNCTIONS[this.currentFunc];

                ctx.strokeStyle = '#6366f1';
                ctx.lineWidth = 3;

                this.plotFunction((x) => func.compute(x, this.params));
            }

            plotFunction(fn) {
                const ctx = this.ctx;
                ctx.beginPath();

                let started = false;
                const step = 2 / this.scale; // Smaller step for smoother curves

                for (let px = 0; px <= this.width; px += 2) {
                    const x = (px - this.centerX) / this.scale;
                    const y = fn(x);

                    if (isNaN(y) || !isFinite(y) || Math.abs(y) > 100) {
                        started = false;
                        continue;
                    }

                    const canvasY = this.centerY - y * this.scale;

                    if (canvasY < -100 || canvasY > this.height + 100) {
                        started = false;
                        continue;
                    }

                    if (!started) {
                        ctx.moveTo(px, canvasY);
                        started = true;
                    } else {
                        ctx.lineTo(px, canvasY);
                    }
                }

                ctx.stroke();
            }
        }

        // ============ INTERSECTION FUNCTIONS ============
        const INTERSECTION_FUNCTIONS = {
            linear: {
                name: '–õ—ñ–Ω—ñ–π–Ω–∞',
                params: [
                    { id: 'k', name: 'k', default: 1 },
                    { id: 'b', name: 'b', default: 0 }
                ],
                compute: (x, p) => p.k * x + p.b,
                latex: (p) => `y = ${p.k === 1 ? '' : p.k}x ${p.b >= 0 ? '+' : '-'} ${Math.abs(p.b)}`,
                isVertical: false
            },
            parabola: {
                name: '–ü–∞—Ä–∞–±–æ–ª–∞',
                params: [
                    { id: 'a', name: 'a', default: 1 },
                    { id: 'bCoef', name: 'b', default: 0 },
                    { id: 'c', name: 'c', default: 0 }
                ],
                compute: (x, p) => p.a * x * x + p.bCoef * x + p.c,
                latex: (p) => `y = ${p.a}x^2 ${p.bCoef >= 0 ? '+' : '-'} ${Math.abs(p.bCoef)}x ${p.c >= 0 ? '+' : '-'} ${Math.abs(p.c)}`,
                isVertical: false
            },
            sqrt: {
                name: '–ö–æ—Ä—ñ–Ω—å',
                params: [
                    { id: 'a', name: 'a', default: 1 },
                    { id: 'b', name: 'b', default: 0 }
                ],
                compute: (x, p) => x >= 0 ? p.a * Math.sqrt(x) + p.b : NaN,
                latex: (p) => `y = ${p.a}\\sqrt{x} ${p.b >= 0 ? '+' : '-'} ${Math.abs(p.b)}`,
                isVertical: false
            },
            abs: {
                name: '–ú–æ–¥—É–ª—å',
                params: [
                    { id: 'a', name: 'a', default: 1 },
                    { id: 'b', name: 'b', default: 0 }
                ],
                compute: (x, p) => p.a * Math.abs(x) + p.b,
                latex: (p) => `y = ${p.a}|x| ${p.b >= 0 ? '+' : '-'} ${Math.abs(p.b)}`,
                isVertical: false
            },
            hyperbola: {
                name: '–ì—ñ–ø–µ—Ä–±–æ–ª–∞',
                params: [
                    { id: 'a', name: 'a', default: 1 },
                    { id: 'b', name: 'b', default: 0 }
                ],
                compute: (x, p) => Math.abs(x) < 0.01 ? NaN : p.a / x + p.b,
                latex: (p) => `y = \\frac{${p.a}}{x} ${p.b >= 0 ? '+' : '-'} ${Math.abs(p.b)}`,
                isVertical: false
            },
            sin: {
                name: '–°–∏–Ω—É—Å',
                params: [
                    { id: 'a', name: 'a', default: 1 },
                    { id: 'k', name: 'k', default: 1 },
                    { id: 'b', name: 'b', default: 0 }
                ],
                compute: (x, p) => p.a * Math.sin(p.k * x) + p.b,
                latex: (p) => `y = ${p.a}\\sin(${p.k}x) ${p.b >= 0 ? '+' : '-'} ${Math.abs(p.b)}`,
                isVertical: false
            },
            cos: {
                name: '–ö–æ—Å–∏–Ω—É—Å',
                params: [
                    { id: 'a', name: 'a', default: 1 },
                    { id: 'k', name: 'k', default: 1 },
                    { id: 'b', name: 'b', default: 0 }
                ],
                compute: (x, p) => p.a * Math.cos(p.k * x) + p.b,
                latex: (p) => `y = ${p.a}\\cos(${p.k}x) ${p.b >= 0 ? '+' : '-'} ${Math.abs(p.b)}`,
                isVertical: false
            },
            exp: {
                name: '–ü–æ–∫–∞–∑–Ω–∏–∫–æ–≤–∞',
                params: [
                    { id: 'base', name: 'a', default: 2 },
                    { id: 'b', name: 'b', default: 0 }
                ],
                compute: (x, p) => Math.pow(p.base, x) + p.b,
                latex: (p) => `y = ${p.base}^x ${p.b >= 0 ? '+' : '-'} ${Math.abs(p.b)}`,
                isVertical: false
            },
            horizontal: {
                name: '–ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞',
                params: [
                    { id: 'c', name: 'c', default: 0 }
                ],
                compute: (x, p) => p.c,
                latex: (p) => `y = ${p.c}`,
                isVertical: false
            },
            vertical: {
                name: '–í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞',
                params: [
                    { id: 'c', name: 'c', default: 0 }
                ],
                compute: (x, p) => NaN, // Special case
                latex: (p) => `x = ${p.c}`,
                isVertical: true
            }
        };

        // ============ INTERSECTION CONTROLLER ============
        class IntersectionController {
            constructor(explorer) {
                this.explorer = explorer;
                this.func1Type = 'linear';
                this.func2Type = 'horizontal';
                this.func1Params = {};
                this.func2Params = {};
                this.intersectionPoints = [];

                this.initParams();
                this.setupEventListeners();
                this.renderParams();
            }

            initParams() {
                const f1 = INTERSECTION_FUNCTIONS[this.func1Type];
                const f2 = INTERSECTION_FUNCTIONS[this.func2Type];

                this.func1Params = {};
                f1.params.forEach(p => this.func1Params[p.id] = p.default);

                this.func2Params = {};
                f2.params.forEach(p => this.func2Params[p.id] = p.default);
            }

            setupEventListeners() {
                document.getElementById('func1Select').addEventListener('change', (e) => {
                    this.func1Type = e.target.value;
                    this.initParamsForFunc(1);
                    this.renderParams();
                    this.explorer.draw();
                });

                document.getElementById('func2Select').addEventListener('change', (e) => {
                    this.func2Type = e.target.value;
                    this.initParamsForFunc(2);
                    this.renderParams();
                    this.explorer.draw();
                });

                document.getElementById('findIntersectionBtn').addEventListener('click', () => {
                    this.findIntersections();
                    this.explorer.draw();
                });
            }

            initParamsForFunc(funcNum) {
                const type = funcNum === 1 ? this.func1Type : this.func2Type;
                const f = INTERSECTION_FUNCTIONS[type];
                const params = {};
                f.params.forEach(p => params[p.id] = p.default);

                if (funcNum === 1) {
                    this.func1Params = params;
                } else {
                    this.func2Params = params;
                }
            }

            renderParams() {
                this.renderFuncParams(1);
                this.renderFuncParams(2);
            }

            renderFuncParams(funcNum) {
                const type = funcNum === 1 ? this.func1Type : this.func2Type;
                const params = funcNum === 1 ? this.func1Params : this.func2Params;
                const f = INTERSECTION_FUNCTIONS[type];
                const container = document.getElementById(`func${funcNum}Params`);

                let html = '';
                f.params.forEach(p => {
                    html += `
                        <div style="flex: 1;">
                            <div class="param-input-label">${p.name}</div>
                            <input type="number" class="param-input"
                                   id="func${funcNum}_${p.id}"
                                   value="${params[p.id]}"
                                   step="0.5">
                        </div>
                    `;
                });
                container.innerHTML = html;

                // Bind events
                f.params.forEach(p => {
                    const input = document.getElementById(`func${funcNum}_${p.id}`);
                    input.addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value) || 0;
                        if (funcNum === 1) {
                            this.func1Params[p.id] = value;
                        } else {
                            this.func2Params[p.id] = value;
                        }
                        this.explorer.draw();
                    });
                });
            }

            getFunc1() {
                const f = INTERSECTION_FUNCTIONS[this.func1Type];
                return {
                    compute: (x) => f.compute(x, this.func1Params),
                    isVertical: f.isVertical,
                    verticalX: f.isVertical ? this.func1Params.c : null
                };
            }

            getFunc2() {
                const f = INTERSECTION_FUNCTIONS[this.func2Type];
                return {
                    compute: (x) => f.compute(x, this.func2Params),
                    isVertical: f.isVertical,
                    verticalX: f.isVertical ? this.func2Params.c : null
                };
            }

            findIntersections() {
                this.intersectionPoints = [];
                const f1 = this.getFunc1();
                const f2 = this.getFunc2();

                // Special cases for vertical lines
                if (f1.isVertical && f2.isVertical) {
                    // Two vertical lines - parallel or same
                    if (f1.verticalX === f2.verticalX) {
                        this.showIntersectionResult('–ü—Ä—è–º—ñ —Å–ø—ñ–≤–ø–∞–¥–∞—é—Ç—å');
                    } else {
                        this.showIntersectionResult('–ü—Ä—è–º—ñ –ø–∞—Ä–∞–ª–µ–ª—å–Ω—ñ, –ø–µ—Ä–µ—Ç–∏–Ω—É –Ω–µ–º–∞—î');
                    }
                    return;
                }

                if (f1.isVertical) {
                    // Find y value of f2 at x = c
                    const x = f1.verticalX;
                    const y = f2.compute(x);
                    if (!isNaN(y) && isFinite(y)) {
                        this.intersectionPoints.push({ x, y });
                    }
                    this.showIntersectionPoints();
                    return;
                }

                if (f2.isVertical) {
                    // Find y value of f1 at x = c
                    const x = f2.verticalX;
                    const y = f1.compute(x);
                    if (!isNaN(y) && isFinite(y)) {
                        this.intersectionPoints.push({ x, y });
                    }
                    this.showIntersectionPoints();
                    return;
                }

                // General case: find where f1(x) = f2(x)
                // Use numerical approach - scan for sign changes
                const xMin = -10;
                const xMax = 10;
                const step = 0.01;

                let prevDiff = null;
                let prevX = null;

                for (let x = xMin; x <= xMax; x += step) {
                    const y1 = f1.compute(x);
                    const y2 = f2.compute(x);

                    if (isNaN(y1) || isNaN(y2) || !isFinite(y1) || !isFinite(y2)) {
                        prevDiff = null;
                        prevX = null;
                        continue;
                    }

                    const diff = y1 - y2;

                    // Check for sign change (intersection)
                    if (prevDiff !== null && prevDiff * diff < 0) {
                        // Refine intersection point using bisection
                        const intersectX = this.bisection(f1.compute, f2.compute, prevX, x);
                        if (intersectX !== null) {
                            const intersectY = f1.compute(intersectX);
                            // Avoid duplicates
                            const isDuplicate = this.intersectionPoints.some(p =>
                                Math.abs(p.x - intersectX) < 0.05
                            );
                            if (!isDuplicate && !isNaN(intersectY) && isFinite(intersectY)) {
                                this.intersectionPoints.push({
                                    x: Math.round(intersectX * 100) / 100,
                                    y: Math.round(intersectY * 100) / 100
                                });
                            }
                        }
                    }

                    // Check for exact intersection (diff very close to 0)
                    if (Math.abs(diff) < 0.001) {
                        const isDuplicate = this.intersectionPoints.some(p =>
                            Math.abs(p.x - x) < 0.05
                        );
                        if (!isDuplicate) {
                            this.intersectionPoints.push({
                                x: Math.round(x * 100) / 100,
                                y: Math.round(y1 * 100) / 100
                            });
                        }
                    }

                    prevDiff = diff;
                    prevX = x;
                }

                this.showIntersectionPoints();
            }

            bisection(f1, f2, a, b) {
                const maxIter = 50;
                const tolerance = 0.0001;

                for (let i = 0; i < maxIter; i++) {
                    const mid = (a + b) / 2;
                    const diffMid = f1(mid) - f2(mid);
                    const diffA = f1(a) - f2(a);

                    if (Math.abs(diffMid) < tolerance || (b - a) / 2 < tolerance) {
                        return mid;
                    }

                    if (diffA * diffMid < 0) {
                        b = mid;
                    } else {
                        a = mid;
                    }
                }
                return (a + b) / 2;
            }

            showIntersectionPoints() {
                const container = document.getElementById('intersectionList');

                if (this.intersectionPoints.length === 0) {
                    container.innerHTML = '<div class="no-intersection">–ü–µ—Ä–µ—Ç–∏–Ω—É –Ω–µ–º–∞—î –Ω–∞ –ø—Ä–æ–º—ñ–∂–∫—É [-10, 10]</div>';
                    return;
                }

                let html = '';
                this.intersectionPoints.forEach((p, i) => {
                    html += `
                        <div class="intersection-point">
                            <div class="point-marker"></div>
                            <span>P${i + 1}: (${p.x}; ${p.y})</span>
                        </div>
                    `;
                });
                container.innerHTML = html;
            }

            showIntersectionResult(message) {
                document.getElementById('intersectionList').innerHTML =
                    `<div class="no-intersection">${message}</div>`;
            }

            getIntersectionPoints() {
                return this.intersectionPoints;
            }
        }

        // Update GraphExplorer to support intersection mode
        const originalGraphExplorerInit = GraphExplorer.prototype.setupEventListeners;
        GraphExplorer.prototype.setupEventListeners = function() {
            originalGraphExplorerInit.call(this);

            // Mode switching
            this.mode = 'transform';
            this.intersectionController = null;

            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    this.mode = tab.dataset.mode;

                    // Toggle visibility
                    document.getElementById('transformMode').style.display =
                        this.mode === 'transform' ? 'block' : 'none';
                    document.getElementById('intersectionMode').classList.toggle('active',
                        this.mode === 'intersection');

                    // Toggle function tabs
                    document.getElementById('functionTabs').style.display =
                        this.mode === 'transform' ? 'flex' : 'none';

                    // Toggle legends
                    document.getElementById('graphLegend').classList.toggle('hidden',
                        this.mode === 'intersection');
                    document.getElementById('intersectionLegend').classList.toggle('hidden',
                        this.mode === 'transform');

                    // Initialize intersection controller if needed
                    if (this.mode === 'intersection' && !this.intersectionController) {
                        this.intersectionController = new IntersectionController(this);
                    }

                    this.draw();
                });
            });
        };

        // Override draw method to handle intersection mode
        const originalDraw = GraphExplorer.prototype.draw;
        GraphExplorer.prototype.draw = function() {
            if (this.mode === 'intersection') {
                this.drawIntersectionMode();
            } else {
                originalDraw.call(this);
            }
        };

        GraphExplorer.prototype.drawIntersectionMode = function() {
            const ctx = this.ctx;
            ctx.clearRect(0, 0, this.width, this.height);

            this.drawGrid();
            this.drawAxes();

            if (!this.intersectionController) return;

            const f1 = this.intersectionController.getFunc1();
            const f2 = this.intersectionController.getFunc2();

            // Draw function 1 (blue)
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = 3;
            if (f1.isVertical) {
                this.drawVerticalLine(f1.verticalX, '#6366f1');
            } else {
                this.plotFunction(f1.compute);
            }

            // Draw function 2 (green)
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 3;
            if (f2.isVertical) {
                this.drawVerticalLine(f2.verticalX, '#10b981');
            } else {
                this.plotFunction(f2.compute);
            }

            // Draw intersection points
            const points = this.intersectionController.getIntersectionPoints();
            points.forEach(p => {
                this.drawIntersectionPoint(p.x, p.y);
            });
        };

        GraphExplorer.prototype.drawVerticalLine = function(x, color) {
            const ctx = this.ctx;
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;

            const canvasX = this.centerX + x * this.scale;
            ctx.beginPath();
            ctx.moveTo(canvasX, 0);
            ctx.lineTo(canvasX, this.height);
            ctx.stroke();
        };

        GraphExplorer.prototype.drawIntersectionPoint = function(x, y) {
            const ctx = this.ctx;
            const canvasX = this.centerX + x * this.scale;
            const canvasY = this.centerY - y * this.scale;

            // Outer circle
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 8, 0, Math.PI * 2);
            ctx.fill();

            // Inner white circle
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 4, 0, Math.PI * 2);
            ctx.fill();

            // Label
            ctx.fillStyle = '#ef4444';
            ctx.font = 'bold 12px Inter';
            ctx.fillText(`(${x}; ${y})`, canvasX + 12, canvasY - 8);
        };

        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            // Wait for KaTeX to load
            if (typeof katex !== 'undefined') {
                new GraphExplorer();
            } else {
                document.addEventListener('katex-loaded', () => new GraphExplorer());
                // Fallback
                setTimeout(() => new GraphExplorer(), 500);
            }
        });
    </script>
</body>
</html>
